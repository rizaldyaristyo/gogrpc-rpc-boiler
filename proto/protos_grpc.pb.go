// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.0--rc2
// source: proto/protos.proto

package protos

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	UtilService_HelloWorld_FullMethodName             = "/protos.UtilService/HelloWorld"
	UtilService_Ping_FullMethodName                   = "/protos.UtilService/Ping"
	UtilService_AuthWithoutCredentials_FullMethodName = "/protos.UtilService/AuthWithoutCredentials"
)

// UtilServiceClient is the client API for UtilService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UtilServiceClient interface {
	HelloWorld(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*StringResponse, error)
	Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*StringResponse, error)
	AuthWithoutCredentials(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*StringResponse, error)
}

type utilServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUtilServiceClient(cc grpc.ClientConnInterface) UtilServiceClient {
	return &utilServiceClient{cc}
}

func (c *utilServiceClient) HelloWorld(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*StringResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StringResponse)
	err := c.cc.Invoke(ctx, UtilService_HelloWorld_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *utilServiceClient) Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*StringResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StringResponse)
	err := c.cc.Invoke(ctx, UtilService_Ping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *utilServiceClient) AuthWithoutCredentials(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*StringResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StringResponse)
	err := c.cc.Invoke(ctx, UtilService_AuthWithoutCredentials_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UtilServiceServer is the server API for UtilService service.
// All implementations must embed UnimplementedUtilServiceServer
// for forward compatibility.
type UtilServiceServer interface {
	HelloWorld(context.Context, *StringRequest) (*StringResponse, error)
	Ping(context.Context, *emptypb.Empty) (*StringResponse, error)
	AuthWithoutCredentials(context.Context, *StringRequest) (*StringResponse, error)
	mustEmbedUnimplementedUtilServiceServer()
}

// UnimplementedUtilServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUtilServiceServer struct{}

func (UnimplementedUtilServiceServer) HelloWorld(context.Context, *StringRequest) (*StringResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HelloWorld not implemented")
}
func (UnimplementedUtilServiceServer) Ping(context.Context, *emptypb.Empty) (*StringResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedUtilServiceServer) AuthWithoutCredentials(context.Context, *StringRequest) (*StringResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthWithoutCredentials not implemented")
}
func (UnimplementedUtilServiceServer) mustEmbedUnimplementedUtilServiceServer() {}
func (UnimplementedUtilServiceServer) testEmbeddedByValue()                     {}

// UnsafeUtilServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UtilServiceServer will
// result in compilation errors.
type UnsafeUtilServiceServer interface {
	mustEmbedUnimplementedUtilServiceServer()
}

func RegisterUtilServiceServer(s grpc.ServiceRegistrar, srv UtilServiceServer) {
	// If the following call pancis, it indicates UnimplementedUtilServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UtilService_ServiceDesc, srv)
}

func _UtilService_HelloWorld_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UtilServiceServer).HelloWorld(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UtilService_HelloWorld_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UtilServiceServer).HelloWorld(ctx, req.(*StringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UtilService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UtilServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UtilService_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UtilServiceServer).Ping(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _UtilService_AuthWithoutCredentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UtilServiceServer).AuthWithoutCredentials(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UtilService_AuthWithoutCredentials_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UtilServiceServer).AuthWithoutCredentials(ctx, req.(*StringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UtilService_ServiceDesc is the grpc.ServiceDesc for UtilService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UtilService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "protos.UtilService",
	HandlerType: (*UtilServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HelloWorld",
			Handler:    _UtilService_HelloWorld_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _UtilService_Ping_Handler,
		},
		{
			MethodName: "AuthWithoutCredentials",
			Handler:    _UtilService_AuthWithoutCredentials_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/protos.proto",
}

const (
	UserService_CreateUser_FullMethodName     = "/protos.UserService/CreateUser"
	UserService_LoginAuth_FullMethodName      = "/protos.UserService/LoginAuth"
	UserService_ChangePassword_FullMethodName = "/protos.UserService/ChangePassword"
	UserService_DeleteUser_FullMethodName     = "/protos.UserService/DeleteUser"
	UserService_GetUser_FullMethodName        = "/protos.UserService/GetUser"
	UserService_DoesUserExist_FullMethodName  = "/protos.UserService/DoesUserExist"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	CreateUser(ctx context.Context, in *UserSensitive, opts ...grpc.CallOption) (*StringResponse, error)
	LoginAuth(ctx context.Context, in *UserPassword, opts ...grpc.CallOption) (*StringResponse, error)
	ChangePassword(ctx context.Context, in *NewPassword, opts ...grpc.CallOption) (*StringResponse, error)
	DeleteUser(ctx context.Context, in *UserIDPassword, opts ...grpc.CallOption) (*StringResponse, error)
	GetUser(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*User, error)
	DoesUserExist(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*BoolResponse, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) CreateUser(ctx context.Context, in *UserSensitive, opts ...grpc.CallOption) (*StringResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StringResponse)
	err := c.cc.Invoke(ctx, UserService_CreateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) LoginAuth(ctx context.Context, in *UserPassword, opts ...grpc.CallOption) (*StringResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StringResponse)
	err := c.cc.Invoke(ctx, UserService_LoginAuth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ChangePassword(ctx context.Context, in *NewPassword, opts ...grpc.CallOption) (*StringResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StringResponse)
	err := c.cc.Invoke(ctx, UserService_ChangePassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) DeleteUser(ctx context.Context, in *UserIDPassword, opts ...grpc.CallOption) (*StringResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StringResponse)
	err := c.cc.Invoke(ctx, UserService_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUser(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserService_GetUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) DoesUserExist(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, UserService_DoesUserExist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility.
type UserServiceServer interface {
	CreateUser(context.Context, *UserSensitive) (*StringResponse, error)
	LoginAuth(context.Context, *UserPassword) (*StringResponse, error)
	ChangePassword(context.Context, *NewPassword) (*StringResponse, error)
	DeleteUser(context.Context, *UserIDPassword) (*StringResponse, error)
	GetUser(context.Context, *IntRequest) (*User, error)
	DoesUserExist(context.Context, *IntRequest) (*BoolResponse, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserServiceServer struct{}

func (UnimplementedUserServiceServer) CreateUser(context.Context, *UserSensitive) (*StringResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedUserServiceServer) LoginAuth(context.Context, *UserPassword) (*StringResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginAuth not implemented")
}
func (UnimplementedUserServiceServer) ChangePassword(context.Context, *NewPassword) (*StringResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangePassword not implemented")
}
func (UnimplementedUserServiceServer) DeleteUser(context.Context, *UserIDPassword) (*StringResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedUserServiceServer) GetUser(context.Context, *IntRequest) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedUserServiceServer) DoesUserExist(context.Context, *IntRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DoesUserExist not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}
func (UnimplementedUserServiceServer) testEmbeddedByValue()                     {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserSensitive)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_CreateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CreateUser(ctx, req.(*UserSensitive))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_LoginAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserPassword)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).LoginAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_LoginAuth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).LoginAuth(ctx, req.(*UserPassword))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_ChangePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewPassword)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).ChangePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_ChangePassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).ChangePassword(ctx, req.(*NewPassword))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserIDPassword)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).DeleteUser(ctx, req.(*UserIDPassword))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUser(ctx, req.(*IntRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_DoesUserExist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).DoesUserExist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_DoesUserExist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).DoesUserExist(ctx, req.(*IntRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "protos.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUser",
			Handler:    _UserService_CreateUser_Handler,
		},
		{
			MethodName: "LoginAuth",
			Handler:    _UserService_LoginAuth_Handler,
		},
		{
			MethodName: "ChangePassword",
			Handler:    _UserService_ChangePassword_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _UserService_DeleteUser_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _UserService_GetUser_Handler,
		},
		{
			MethodName: "DoesUserExist",
			Handler:    _UserService_DoesUserExist_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/protos.proto",
}

const (
	CategoryService_CreateCategory_FullMethodName      = "/protos.CategoryService/CreateCategory"
	CategoryService_GetCategories_FullMethodName       = "/protos.CategoryService/GetCategories"
	CategoryService_GetCategoriesByName_FullMethodName = "/protos.CategoryService/GetCategoriesByName"
	CategoryService_GetCategoryByID_FullMethodName     = "/protos.CategoryService/GetCategoryByID"
	CategoryService_EditCategory_FullMethodName        = "/protos.CategoryService/EditCategory"
	CategoryService_DeleteCategory_FullMethodName      = "/protos.CategoryService/DeleteCategory"
	CategoryService_DoesCategoryExist_FullMethodName   = "/protos.CategoryService/DoesCategoryExist"
)

// CategoryServiceClient is the client API for CategoryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CategoryServiceClient interface {
	CreateCategory(ctx context.Context, in *Category, opts ...grpc.CallOption) (*StringResponse, error)
	GetCategories(ctx context.Context, in *IDLimits, opts ...grpc.CallOption) (*CategoryMins, error)
	GetCategoriesByName(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*CategoryMins, error)
	GetCategoryByID(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*Category, error)
	EditCategory(ctx context.Context, in *UpdateCategory, opts ...grpc.CallOption) (*StringResponse, error)
	DeleteCategory(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*StringResponse, error)
	DoesCategoryExist(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*BoolResponse, error)
}

type categoryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCategoryServiceClient(cc grpc.ClientConnInterface) CategoryServiceClient {
	return &categoryServiceClient{cc}
}

func (c *categoryServiceClient) CreateCategory(ctx context.Context, in *Category, opts ...grpc.CallOption) (*StringResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StringResponse)
	err := c.cc.Invoke(ctx, CategoryService_CreateCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) GetCategories(ctx context.Context, in *IDLimits, opts ...grpc.CallOption) (*CategoryMins, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CategoryMins)
	err := c.cc.Invoke(ctx, CategoryService_GetCategories_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) GetCategoriesByName(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*CategoryMins, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CategoryMins)
	err := c.cc.Invoke(ctx, CategoryService_GetCategoriesByName_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) GetCategoryByID(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*Category, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Category)
	err := c.cc.Invoke(ctx, CategoryService_GetCategoryByID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) EditCategory(ctx context.Context, in *UpdateCategory, opts ...grpc.CallOption) (*StringResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StringResponse)
	err := c.cc.Invoke(ctx, CategoryService_EditCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) DeleteCategory(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*StringResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StringResponse)
	err := c.cc.Invoke(ctx, CategoryService_DeleteCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) DoesCategoryExist(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, CategoryService_DoesCategoryExist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CategoryServiceServer is the server API for CategoryService service.
// All implementations must embed UnimplementedCategoryServiceServer
// for forward compatibility.
type CategoryServiceServer interface {
	CreateCategory(context.Context, *Category) (*StringResponse, error)
	GetCategories(context.Context, *IDLimits) (*CategoryMins, error)
	GetCategoriesByName(context.Context, *StringRequest) (*CategoryMins, error)
	GetCategoryByID(context.Context, *IntRequest) (*Category, error)
	EditCategory(context.Context, *UpdateCategory) (*StringResponse, error)
	DeleteCategory(context.Context, *IntRequest) (*StringResponse, error)
	DoesCategoryExist(context.Context, *IntRequest) (*BoolResponse, error)
	mustEmbedUnimplementedCategoryServiceServer()
}

// UnimplementedCategoryServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCategoryServiceServer struct{}

func (UnimplementedCategoryServiceServer) CreateCategory(context.Context, *Category) (*StringResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCategory not implemented")
}
func (UnimplementedCategoryServiceServer) GetCategories(context.Context, *IDLimits) (*CategoryMins, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCategories not implemented")
}
func (UnimplementedCategoryServiceServer) GetCategoriesByName(context.Context, *StringRequest) (*CategoryMins, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCategoriesByName not implemented")
}
func (UnimplementedCategoryServiceServer) GetCategoryByID(context.Context, *IntRequest) (*Category, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCategoryByID not implemented")
}
func (UnimplementedCategoryServiceServer) EditCategory(context.Context, *UpdateCategory) (*StringResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EditCategory not implemented")
}
func (UnimplementedCategoryServiceServer) DeleteCategory(context.Context, *IntRequest) (*StringResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCategory not implemented")
}
func (UnimplementedCategoryServiceServer) DoesCategoryExist(context.Context, *IntRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DoesCategoryExist not implemented")
}
func (UnimplementedCategoryServiceServer) mustEmbedUnimplementedCategoryServiceServer() {}
func (UnimplementedCategoryServiceServer) testEmbeddedByValue()                         {}

// UnsafeCategoryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CategoryServiceServer will
// result in compilation errors.
type UnsafeCategoryServiceServer interface {
	mustEmbedUnimplementedCategoryServiceServer()
}

func RegisterCategoryServiceServer(s grpc.ServiceRegistrar, srv CategoryServiceServer) {
	// If the following call pancis, it indicates UnimplementedCategoryServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CategoryService_ServiceDesc, srv)
}

func _CategoryService_CreateCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Category)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).CreateCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_CreateCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).CreateCategory(ctx, req.(*Category))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_GetCategories_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDLimits)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).GetCategories(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_GetCategories_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).GetCategories(ctx, req.(*IDLimits))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_GetCategoriesByName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).GetCategoriesByName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_GetCategoriesByName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).GetCategoriesByName(ctx, req.(*StringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_GetCategoryByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).GetCategoryByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_GetCategoryByID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).GetCategoryByID(ctx, req.(*IntRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_EditCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCategory)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).EditCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_EditCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).EditCategory(ctx, req.(*UpdateCategory))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_DeleteCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).DeleteCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_DeleteCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).DeleteCategory(ctx, req.(*IntRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_DoesCategoryExist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).DoesCategoryExist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_DoesCategoryExist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).DoesCategoryExist(ctx, req.(*IntRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CategoryService_ServiceDesc is the grpc.ServiceDesc for CategoryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CategoryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "protos.CategoryService",
	HandlerType: (*CategoryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCategory",
			Handler:    _CategoryService_CreateCategory_Handler,
		},
		{
			MethodName: "GetCategories",
			Handler:    _CategoryService_GetCategories_Handler,
		},
		{
			MethodName: "GetCategoriesByName",
			Handler:    _CategoryService_GetCategoriesByName_Handler,
		},
		{
			MethodName: "GetCategoryByID",
			Handler:    _CategoryService_GetCategoryByID_Handler,
		},
		{
			MethodName: "EditCategory",
			Handler:    _CategoryService_EditCategory_Handler,
		},
		{
			MethodName: "DeleteCategory",
			Handler:    _CategoryService_DeleteCategory_Handler,
		},
		{
			MethodName: "DoesCategoryExist",
			Handler:    _CategoryService_DoesCategoryExist_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/protos.proto",
}

const (
	AuthorService_CreateAuthor_FullMethodName     = "/protos.AuthorService/CreateAuthor"
	AuthorService_GetAuthors_FullMethodName       = "/protos.AuthorService/GetAuthors"
	AuthorService_GetAuthorsByName_FullMethodName = "/protos.AuthorService/GetAuthorsByName"
	AuthorService_GetAuthorByID_FullMethodName    = "/protos.AuthorService/GetAuthorByID"
	AuthorService_EditAuthor_FullMethodName       = "/protos.AuthorService/EditAuthor"
	AuthorService_DeleteAuthor_FullMethodName     = "/protos.AuthorService/DeleteAuthor"
	AuthorService_DoesAuthorExist_FullMethodName  = "/protos.AuthorService/DoesAuthorExist"
)

// AuthorServiceClient is the client API for AuthorService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthorServiceClient interface {
	CreateAuthor(ctx context.Context, in *Author, opts ...grpc.CallOption) (*StringResponse, error)
	GetAuthors(ctx context.Context, in *IDLimits, opts ...grpc.CallOption) (*AuthorMins, error)
	GetAuthorsByName(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*AuthorMins, error)
	GetAuthorByID(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*Author, error)
	EditAuthor(ctx context.Context, in *UpdateAuthor, opts ...grpc.CallOption) (*StringResponse, error)
	DeleteAuthor(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*StringResponse, error)
	DoesAuthorExist(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*BoolResponse, error)
}

type authorServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthorServiceClient(cc grpc.ClientConnInterface) AuthorServiceClient {
	return &authorServiceClient{cc}
}

func (c *authorServiceClient) CreateAuthor(ctx context.Context, in *Author, opts ...grpc.CallOption) (*StringResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StringResponse)
	err := c.cc.Invoke(ctx, AuthorService_CreateAuthor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authorServiceClient) GetAuthors(ctx context.Context, in *IDLimits, opts ...grpc.CallOption) (*AuthorMins, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AuthorMins)
	err := c.cc.Invoke(ctx, AuthorService_GetAuthors_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authorServiceClient) GetAuthorsByName(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*AuthorMins, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AuthorMins)
	err := c.cc.Invoke(ctx, AuthorService_GetAuthorsByName_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authorServiceClient) GetAuthorByID(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*Author, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Author)
	err := c.cc.Invoke(ctx, AuthorService_GetAuthorByID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authorServiceClient) EditAuthor(ctx context.Context, in *UpdateAuthor, opts ...grpc.CallOption) (*StringResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StringResponse)
	err := c.cc.Invoke(ctx, AuthorService_EditAuthor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authorServiceClient) DeleteAuthor(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*StringResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StringResponse)
	err := c.cc.Invoke(ctx, AuthorService_DeleteAuthor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authorServiceClient) DoesAuthorExist(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, AuthorService_DoesAuthorExist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthorServiceServer is the server API for AuthorService service.
// All implementations must embed UnimplementedAuthorServiceServer
// for forward compatibility.
type AuthorServiceServer interface {
	CreateAuthor(context.Context, *Author) (*StringResponse, error)
	GetAuthors(context.Context, *IDLimits) (*AuthorMins, error)
	GetAuthorsByName(context.Context, *StringRequest) (*AuthorMins, error)
	GetAuthorByID(context.Context, *IntRequest) (*Author, error)
	EditAuthor(context.Context, *UpdateAuthor) (*StringResponse, error)
	DeleteAuthor(context.Context, *IntRequest) (*StringResponse, error)
	DoesAuthorExist(context.Context, *IntRequest) (*BoolResponse, error)
	mustEmbedUnimplementedAuthorServiceServer()
}

// UnimplementedAuthorServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAuthorServiceServer struct{}

func (UnimplementedAuthorServiceServer) CreateAuthor(context.Context, *Author) (*StringResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAuthor not implemented")
}
func (UnimplementedAuthorServiceServer) GetAuthors(context.Context, *IDLimits) (*AuthorMins, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAuthors not implemented")
}
func (UnimplementedAuthorServiceServer) GetAuthorsByName(context.Context, *StringRequest) (*AuthorMins, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAuthorsByName not implemented")
}
func (UnimplementedAuthorServiceServer) GetAuthorByID(context.Context, *IntRequest) (*Author, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAuthorByID not implemented")
}
func (UnimplementedAuthorServiceServer) EditAuthor(context.Context, *UpdateAuthor) (*StringResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EditAuthor not implemented")
}
func (UnimplementedAuthorServiceServer) DeleteAuthor(context.Context, *IntRequest) (*StringResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAuthor not implemented")
}
func (UnimplementedAuthorServiceServer) DoesAuthorExist(context.Context, *IntRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DoesAuthorExist not implemented")
}
func (UnimplementedAuthorServiceServer) mustEmbedUnimplementedAuthorServiceServer() {}
func (UnimplementedAuthorServiceServer) testEmbeddedByValue()                       {}

// UnsafeAuthorServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthorServiceServer will
// result in compilation errors.
type UnsafeAuthorServiceServer interface {
	mustEmbedUnimplementedAuthorServiceServer()
}

func RegisterAuthorServiceServer(s grpc.ServiceRegistrar, srv AuthorServiceServer) {
	// If the following call pancis, it indicates UnimplementedAuthorServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AuthorService_ServiceDesc, srv)
}

func _AuthorService_CreateAuthor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Author)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorServiceServer).CreateAuthor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthorService_CreateAuthor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorServiceServer).CreateAuthor(ctx, req.(*Author))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthorService_GetAuthors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDLimits)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorServiceServer).GetAuthors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthorService_GetAuthors_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorServiceServer).GetAuthors(ctx, req.(*IDLimits))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthorService_GetAuthorsByName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorServiceServer).GetAuthorsByName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthorService_GetAuthorsByName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorServiceServer).GetAuthorsByName(ctx, req.(*StringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthorService_GetAuthorByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorServiceServer).GetAuthorByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthorService_GetAuthorByID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorServiceServer).GetAuthorByID(ctx, req.(*IntRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthorService_EditAuthor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAuthor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorServiceServer).EditAuthor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthorService_EditAuthor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorServiceServer).EditAuthor(ctx, req.(*UpdateAuthor))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthorService_DeleteAuthor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorServiceServer).DeleteAuthor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthorService_DeleteAuthor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorServiceServer).DeleteAuthor(ctx, req.(*IntRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthorService_DoesAuthorExist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorServiceServer).DoesAuthorExist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthorService_DoesAuthorExist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorServiceServer).DoesAuthorExist(ctx, req.(*IntRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthorService_ServiceDesc is the grpc.ServiceDesc for AuthorService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthorService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "protos.AuthorService",
	HandlerType: (*AuthorServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAuthor",
			Handler:    _AuthorService_CreateAuthor_Handler,
		},
		{
			MethodName: "GetAuthors",
			Handler:    _AuthorService_GetAuthors_Handler,
		},
		{
			MethodName: "GetAuthorsByName",
			Handler:    _AuthorService_GetAuthorsByName_Handler,
		},
		{
			MethodName: "GetAuthorByID",
			Handler:    _AuthorService_GetAuthorByID_Handler,
		},
		{
			MethodName: "EditAuthor",
			Handler:    _AuthorService_EditAuthor_Handler,
		},
		{
			MethodName: "DeleteAuthor",
			Handler:    _AuthorService_DeleteAuthor_Handler,
		},
		{
			MethodName: "DoesAuthorExist",
			Handler:    _AuthorService_DoesAuthorExist_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/protos.proto",
}

const (
	BookAndBorrowService_IsAuthorInUseByBook_FullMethodName    = "/protos.BookAndBorrowService/IsAuthorInUseByBook"
	BookAndBorrowService_IsCategoryInUseByBook_FullMethodName  = "/protos.BookAndBorrowService/IsCategoryInUseByBook"
	BookAndBorrowService_CreateBook_FullMethodName             = "/protos.BookAndBorrowService/CreateBook"
	BookAndBorrowService_GetBooks_FullMethodName               = "/protos.BookAndBorrowService/GetBooks"
	BookAndBorrowService_GetBooksByDate_FullMethodName         = "/protos.BookAndBorrowService/GetBooksByDate"
	BookAndBorrowService_GetBooksByName_FullMethodName         = "/protos.BookAndBorrowService/GetBooksByName"
	BookAndBorrowService_GetBookByID_FullMethodName            = "/protos.BookAndBorrowService/GetBookByID"
	BookAndBorrowService_EditBook_FullMethodName               = "/protos.BookAndBorrowService/EditBook"
	BookAndBorrowService_DeleteBook_FullMethodName             = "/protos.BookAndBorrowService/DeleteBook"
	BookAndBorrowService_DoesUserStillBorrow_FullMethodName    = "/protos.BookAndBorrowService/DoesUserStillBorrow"
	BookAndBorrowService_CreateBorrow_FullMethodName           = "/protos.BookAndBorrowService/CreateBorrow"
	BookAndBorrowService_CreateReturn_FullMethodName           = "/protos.BookAndBorrowService/CreateReturn"
	BookAndBorrowService_GetBorrowings_FullMethodName          = "/protos.BookAndBorrowService/GetBorrowings"
	BookAndBorrowService_GetBorrowingsByDate_FullMethodName    = "/protos.BookAndBorrowService/GetBorrowingsByDate"
	BookAndBorrowService_GetBorrowingsByUserID_FullMethodName  = "/protos.BookAndBorrowService/GetBorrowingsByUserID"
	BookAndBorrowService_GetReturns_FullMethodName             = "/protos.BookAndBorrowService/GetReturns"
	BookAndBorrowService_GetReturnsByDate_FullMethodName       = "/protos.BookAndBorrowService/GetReturnsByDate"
	BookAndBorrowService_GetReturnsByUserID_FullMethodName     = "/protos.BookAndBorrowService/GetReturnsByUserID"
	BookAndBorrowService_GetOverdues_FullMethodName            = "/protos.BookAndBorrowService/GetOverdues"
	BookAndBorrowService_EditBorrow_FullMethodName             = "/protos.BookAndBorrowService/EditBorrow"
	BookAndBorrowService_DeleteBorrow_FullMethodName           = "/protos.BookAndBorrowService/DeleteBorrow"
	BookAndBorrowService_GetBookRecommendations_FullMethodName = "/protos.BookAndBorrowService/GetBookRecommendations"
)

// BookAndBorrowServiceClient is the client API for BookAndBorrowService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BookAndBorrowServiceClient interface {
	IsAuthorInUseByBook(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	IsCategoryInUseByBook(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	CreateBook(ctx context.Context, in *Book, opts ...grpc.CallOption) (*StringResponse, error)
	GetBooks(ctx context.Context, in *IDLimits, opts ...grpc.CallOption) (*BookMins, error)
	GetBooksByDate(ctx context.Context, in *DateLimits, opts ...grpc.CallOption) (*BookMins, error)
	GetBooksByName(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*BookMins, error)
	GetBookByID(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*Book, error)
	EditBook(ctx context.Context, in *UpdateBook, opts ...grpc.CallOption) (*StringResponse, error)
	DeleteBook(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*StringResponse, error)
	DoesUserStillBorrow(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	CreateBorrow(ctx context.Context, in *Borrow, opts ...grpc.CallOption) (*StringResponse, error)
	CreateReturn(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*StringResponse, error)
	GetBorrowings(ctx context.Context, in *IDLimits, opts ...grpc.CallOption) (*BorrowOrReturnMins, error)
	GetBorrowingsByDate(ctx context.Context, in *DateLimits, opts ...grpc.CallOption) (*BorrowOrReturnMins, error)
	GetBorrowingsByUserID(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*BorrowOrReturnMins, error)
	GetReturns(ctx context.Context, in *IDLimits, opts ...grpc.CallOption) (*BorrowOrReturnMins, error)
	GetReturnsByDate(ctx context.Context, in *DateLimits, opts ...grpc.CallOption) (*BorrowOrReturnMins, error)
	GetReturnsByUserID(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*BorrowOrReturnMins, error)
	GetOverdues(ctx context.Context, in *DateLimits, opts ...grpc.CallOption) (*BorrowOrReturnMins, error)
	EditBorrow(ctx context.Context, in *UpdateBorrow, opts ...grpc.CallOption) (*StringResponse, error)
	DeleteBorrow(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*StringResponse, error)
	GetBookRecommendations(ctx context.Context, in *GetRecommendation, opts ...grpc.CallOption) (*BookMins, error)
}

type bookAndBorrowServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBookAndBorrowServiceClient(cc grpc.ClientConnInterface) BookAndBorrowServiceClient {
	return &bookAndBorrowServiceClient{cc}
}

func (c *bookAndBorrowServiceClient) IsAuthorInUseByBook(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, BookAndBorrowService_IsAuthorInUseByBook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookAndBorrowServiceClient) IsCategoryInUseByBook(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, BookAndBorrowService_IsCategoryInUseByBook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookAndBorrowServiceClient) CreateBook(ctx context.Context, in *Book, opts ...grpc.CallOption) (*StringResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StringResponse)
	err := c.cc.Invoke(ctx, BookAndBorrowService_CreateBook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookAndBorrowServiceClient) GetBooks(ctx context.Context, in *IDLimits, opts ...grpc.CallOption) (*BookMins, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BookMins)
	err := c.cc.Invoke(ctx, BookAndBorrowService_GetBooks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookAndBorrowServiceClient) GetBooksByDate(ctx context.Context, in *DateLimits, opts ...grpc.CallOption) (*BookMins, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BookMins)
	err := c.cc.Invoke(ctx, BookAndBorrowService_GetBooksByDate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookAndBorrowServiceClient) GetBooksByName(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*BookMins, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BookMins)
	err := c.cc.Invoke(ctx, BookAndBorrowService_GetBooksByName_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookAndBorrowServiceClient) GetBookByID(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*Book, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Book)
	err := c.cc.Invoke(ctx, BookAndBorrowService_GetBookByID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookAndBorrowServiceClient) EditBook(ctx context.Context, in *UpdateBook, opts ...grpc.CallOption) (*StringResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StringResponse)
	err := c.cc.Invoke(ctx, BookAndBorrowService_EditBook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookAndBorrowServiceClient) DeleteBook(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*StringResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StringResponse)
	err := c.cc.Invoke(ctx, BookAndBorrowService_DeleteBook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookAndBorrowServiceClient) DoesUserStillBorrow(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BoolResponse)
	err := c.cc.Invoke(ctx, BookAndBorrowService_DoesUserStillBorrow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookAndBorrowServiceClient) CreateBorrow(ctx context.Context, in *Borrow, opts ...grpc.CallOption) (*StringResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StringResponse)
	err := c.cc.Invoke(ctx, BookAndBorrowService_CreateBorrow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookAndBorrowServiceClient) CreateReturn(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*StringResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StringResponse)
	err := c.cc.Invoke(ctx, BookAndBorrowService_CreateReturn_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookAndBorrowServiceClient) GetBorrowings(ctx context.Context, in *IDLimits, opts ...grpc.CallOption) (*BorrowOrReturnMins, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BorrowOrReturnMins)
	err := c.cc.Invoke(ctx, BookAndBorrowService_GetBorrowings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookAndBorrowServiceClient) GetBorrowingsByDate(ctx context.Context, in *DateLimits, opts ...grpc.CallOption) (*BorrowOrReturnMins, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BorrowOrReturnMins)
	err := c.cc.Invoke(ctx, BookAndBorrowService_GetBorrowingsByDate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookAndBorrowServiceClient) GetBorrowingsByUserID(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*BorrowOrReturnMins, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BorrowOrReturnMins)
	err := c.cc.Invoke(ctx, BookAndBorrowService_GetBorrowingsByUserID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookAndBorrowServiceClient) GetReturns(ctx context.Context, in *IDLimits, opts ...grpc.CallOption) (*BorrowOrReturnMins, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BorrowOrReturnMins)
	err := c.cc.Invoke(ctx, BookAndBorrowService_GetReturns_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookAndBorrowServiceClient) GetReturnsByDate(ctx context.Context, in *DateLimits, opts ...grpc.CallOption) (*BorrowOrReturnMins, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BorrowOrReturnMins)
	err := c.cc.Invoke(ctx, BookAndBorrowService_GetReturnsByDate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookAndBorrowServiceClient) GetReturnsByUserID(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*BorrowOrReturnMins, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BorrowOrReturnMins)
	err := c.cc.Invoke(ctx, BookAndBorrowService_GetReturnsByUserID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookAndBorrowServiceClient) GetOverdues(ctx context.Context, in *DateLimits, opts ...grpc.CallOption) (*BorrowOrReturnMins, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BorrowOrReturnMins)
	err := c.cc.Invoke(ctx, BookAndBorrowService_GetOverdues_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookAndBorrowServiceClient) EditBorrow(ctx context.Context, in *UpdateBorrow, opts ...grpc.CallOption) (*StringResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StringResponse)
	err := c.cc.Invoke(ctx, BookAndBorrowService_EditBorrow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookAndBorrowServiceClient) DeleteBorrow(ctx context.Context, in *IntRequest, opts ...grpc.CallOption) (*StringResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StringResponse)
	err := c.cc.Invoke(ctx, BookAndBorrowService_DeleteBorrow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookAndBorrowServiceClient) GetBookRecommendations(ctx context.Context, in *GetRecommendation, opts ...grpc.CallOption) (*BookMins, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BookMins)
	err := c.cc.Invoke(ctx, BookAndBorrowService_GetBookRecommendations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BookAndBorrowServiceServer is the server API for BookAndBorrowService service.
// All implementations must embed UnimplementedBookAndBorrowServiceServer
// for forward compatibility.
type BookAndBorrowServiceServer interface {
	IsAuthorInUseByBook(context.Context, *IntRequest) (*BoolResponse, error)
	IsCategoryInUseByBook(context.Context, *IntRequest) (*BoolResponse, error)
	CreateBook(context.Context, *Book) (*StringResponse, error)
	GetBooks(context.Context, *IDLimits) (*BookMins, error)
	GetBooksByDate(context.Context, *DateLimits) (*BookMins, error)
	GetBooksByName(context.Context, *StringRequest) (*BookMins, error)
	GetBookByID(context.Context, *IntRequest) (*Book, error)
	EditBook(context.Context, *UpdateBook) (*StringResponse, error)
	DeleteBook(context.Context, *IntRequest) (*StringResponse, error)
	DoesUserStillBorrow(context.Context, *IntRequest) (*BoolResponse, error)
	CreateBorrow(context.Context, *Borrow) (*StringResponse, error)
	CreateReturn(context.Context, *IntRequest) (*StringResponse, error)
	GetBorrowings(context.Context, *IDLimits) (*BorrowOrReturnMins, error)
	GetBorrowingsByDate(context.Context, *DateLimits) (*BorrowOrReturnMins, error)
	GetBorrowingsByUserID(context.Context, *IntRequest) (*BorrowOrReturnMins, error)
	GetReturns(context.Context, *IDLimits) (*BorrowOrReturnMins, error)
	GetReturnsByDate(context.Context, *DateLimits) (*BorrowOrReturnMins, error)
	GetReturnsByUserID(context.Context, *IntRequest) (*BorrowOrReturnMins, error)
	GetOverdues(context.Context, *DateLimits) (*BorrowOrReturnMins, error)
	EditBorrow(context.Context, *UpdateBorrow) (*StringResponse, error)
	DeleteBorrow(context.Context, *IntRequest) (*StringResponse, error)
	GetBookRecommendations(context.Context, *GetRecommendation) (*BookMins, error)
	mustEmbedUnimplementedBookAndBorrowServiceServer()
}

// UnimplementedBookAndBorrowServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBookAndBorrowServiceServer struct{}

func (UnimplementedBookAndBorrowServiceServer) IsAuthorInUseByBook(context.Context, *IntRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsAuthorInUseByBook not implemented")
}
func (UnimplementedBookAndBorrowServiceServer) IsCategoryInUseByBook(context.Context, *IntRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsCategoryInUseByBook not implemented")
}
func (UnimplementedBookAndBorrowServiceServer) CreateBook(context.Context, *Book) (*StringResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBook not implemented")
}
func (UnimplementedBookAndBorrowServiceServer) GetBooks(context.Context, *IDLimits) (*BookMins, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBooks not implemented")
}
func (UnimplementedBookAndBorrowServiceServer) GetBooksByDate(context.Context, *DateLimits) (*BookMins, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBooksByDate not implemented")
}
func (UnimplementedBookAndBorrowServiceServer) GetBooksByName(context.Context, *StringRequest) (*BookMins, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBooksByName not implemented")
}
func (UnimplementedBookAndBorrowServiceServer) GetBookByID(context.Context, *IntRequest) (*Book, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBookByID not implemented")
}
func (UnimplementedBookAndBorrowServiceServer) EditBook(context.Context, *UpdateBook) (*StringResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EditBook not implemented")
}
func (UnimplementedBookAndBorrowServiceServer) DeleteBook(context.Context, *IntRequest) (*StringResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBook not implemented")
}
func (UnimplementedBookAndBorrowServiceServer) DoesUserStillBorrow(context.Context, *IntRequest) (*BoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DoesUserStillBorrow not implemented")
}
func (UnimplementedBookAndBorrowServiceServer) CreateBorrow(context.Context, *Borrow) (*StringResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBorrow not implemented")
}
func (UnimplementedBookAndBorrowServiceServer) CreateReturn(context.Context, *IntRequest) (*StringResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateReturn not implemented")
}
func (UnimplementedBookAndBorrowServiceServer) GetBorrowings(context.Context, *IDLimits) (*BorrowOrReturnMins, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBorrowings not implemented")
}
func (UnimplementedBookAndBorrowServiceServer) GetBorrowingsByDate(context.Context, *DateLimits) (*BorrowOrReturnMins, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBorrowingsByDate not implemented")
}
func (UnimplementedBookAndBorrowServiceServer) GetBorrowingsByUserID(context.Context, *IntRequest) (*BorrowOrReturnMins, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBorrowingsByUserID not implemented")
}
func (UnimplementedBookAndBorrowServiceServer) GetReturns(context.Context, *IDLimits) (*BorrowOrReturnMins, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReturns not implemented")
}
func (UnimplementedBookAndBorrowServiceServer) GetReturnsByDate(context.Context, *DateLimits) (*BorrowOrReturnMins, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReturnsByDate not implemented")
}
func (UnimplementedBookAndBorrowServiceServer) GetReturnsByUserID(context.Context, *IntRequest) (*BorrowOrReturnMins, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReturnsByUserID not implemented")
}
func (UnimplementedBookAndBorrowServiceServer) GetOverdues(context.Context, *DateLimits) (*BorrowOrReturnMins, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOverdues not implemented")
}
func (UnimplementedBookAndBorrowServiceServer) EditBorrow(context.Context, *UpdateBorrow) (*StringResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EditBorrow not implemented")
}
func (UnimplementedBookAndBorrowServiceServer) DeleteBorrow(context.Context, *IntRequest) (*StringResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBorrow not implemented")
}
func (UnimplementedBookAndBorrowServiceServer) GetBookRecommendations(context.Context, *GetRecommendation) (*BookMins, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBookRecommendations not implemented")
}
func (UnimplementedBookAndBorrowServiceServer) mustEmbedUnimplementedBookAndBorrowServiceServer() {}
func (UnimplementedBookAndBorrowServiceServer) testEmbeddedByValue()                              {}

// UnsafeBookAndBorrowServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BookAndBorrowServiceServer will
// result in compilation errors.
type UnsafeBookAndBorrowServiceServer interface {
	mustEmbedUnimplementedBookAndBorrowServiceServer()
}

func RegisterBookAndBorrowServiceServer(s grpc.ServiceRegistrar, srv BookAndBorrowServiceServer) {
	// If the following call pancis, it indicates UnimplementedBookAndBorrowServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BookAndBorrowService_ServiceDesc, srv)
}

func _BookAndBorrowService_IsAuthorInUseByBook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookAndBorrowServiceServer).IsAuthorInUseByBook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookAndBorrowService_IsAuthorInUseByBook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookAndBorrowServiceServer).IsAuthorInUseByBook(ctx, req.(*IntRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookAndBorrowService_IsCategoryInUseByBook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookAndBorrowServiceServer).IsCategoryInUseByBook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookAndBorrowService_IsCategoryInUseByBook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookAndBorrowServiceServer).IsCategoryInUseByBook(ctx, req.(*IntRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookAndBorrowService_CreateBook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Book)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookAndBorrowServiceServer).CreateBook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookAndBorrowService_CreateBook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookAndBorrowServiceServer).CreateBook(ctx, req.(*Book))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookAndBorrowService_GetBooks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDLimits)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookAndBorrowServiceServer).GetBooks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookAndBorrowService_GetBooks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookAndBorrowServiceServer).GetBooks(ctx, req.(*IDLimits))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookAndBorrowService_GetBooksByDate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DateLimits)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookAndBorrowServiceServer).GetBooksByDate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookAndBorrowService_GetBooksByDate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookAndBorrowServiceServer).GetBooksByDate(ctx, req.(*DateLimits))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookAndBorrowService_GetBooksByName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookAndBorrowServiceServer).GetBooksByName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookAndBorrowService_GetBooksByName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookAndBorrowServiceServer).GetBooksByName(ctx, req.(*StringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookAndBorrowService_GetBookByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookAndBorrowServiceServer).GetBookByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookAndBorrowService_GetBookByID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookAndBorrowServiceServer).GetBookByID(ctx, req.(*IntRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookAndBorrowService_EditBook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateBook)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookAndBorrowServiceServer).EditBook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookAndBorrowService_EditBook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookAndBorrowServiceServer).EditBook(ctx, req.(*UpdateBook))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookAndBorrowService_DeleteBook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookAndBorrowServiceServer).DeleteBook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookAndBorrowService_DeleteBook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookAndBorrowServiceServer).DeleteBook(ctx, req.(*IntRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookAndBorrowService_DoesUserStillBorrow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookAndBorrowServiceServer).DoesUserStillBorrow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookAndBorrowService_DoesUserStillBorrow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookAndBorrowServiceServer).DoesUserStillBorrow(ctx, req.(*IntRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookAndBorrowService_CreateBorrow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Borrow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookAndBorrowServiceServer).CreateBorrow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookAndBorrowService_CreateBorrow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookAndBorrowServiceServer).CreateBorrow(ctx, req.(*Borrow))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookAndBorrowService_CreateReturn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookAndBorrowServiceServer).CreateReturn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookAndBorrowService_CreateReturn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookAndBorrowServiceServer).CreateReturn(ctx, req.(*IntRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookAndBorrowService_GetBorrowings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDLimits)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookAndBorrowServiceServer).GetBorrowings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookAndBorrowService_GetBorrowings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookAndBorrowServiceServer).GetBorrowings(ctx, req.(*IDLimits))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookAndBorrowService_GetBorrowingsByDate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DateLimits)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookAndBorrowServiceServer).GetBorrowingsByDate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookAndBorrowService_GetBorrowingsByDate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookAndBorrowServiceServer).GetBorrowingsByDate(ctx, req.(*DateLimits))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookAndBorrowService_GetBorrowingsByUserID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookAndBorrowServiceServer).GetBorrowingsByUserID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookAndBorrowService_GetBorrowingsByUserID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookAndBorrowServiceServer).GetBorrowingsByUserID(ctx, req.(*IntRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookAndBorrowService_GetReturns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDLimits)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookAndBorrowServiceServer).GetReturns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookAndBorrowService_GetReturns_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookAndBorrowServiceServer).GetReturns(ctx, req.(*IDLimits))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookAndBorrowService_GetReturnsByDate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DateLimits)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookAndBorrowServiceServer).GetReturnsByDate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookAndBorrowService_GetReturnsByDate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookAndBorrowServiceServer).GetReturnsByDate(ctx, req.(*DateLimits))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookAndBorrowService_GetReturnsByUserID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookAndBorrowServiceServer).GetReturnsByUserID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookAndBorrowService_GetReturnsByUserID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookAndBorrowServiceServer).GetReturnsByUserID(ctx, req.(*IntRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookAndBorrowService_GetOverdues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DateLimits)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookAndBorrowServiceServer).GetOverdues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookAndBorrowService_GetOverdues_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookAndBorrowServiceServer).GetOverdues(ctx, req.(*DateLimits))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookAndBorrowService_EditBorrow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateBorrow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookAndBorrowServiceServer).EditBorrow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookAndBorrowService_EditBorrow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookAndBorrowServiceServer).EditBorrow(ctx, req.(*UpdateBorrow))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookAndBorrowService_DeleteBorrow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookAndBorrowServiceServer).DeleteBorrow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookAndBorrowService_DeleteBorrow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookAndBorrowServiceServer).DeleteBorrow(ctx, req.(*IntRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookAndBorrowService_GetBookRecommendations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRecommendation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookAndBorrowServiceServer).GetBookRecommendations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BookAndBorrowService_GetBookRecommendations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookAndBorrowServiceServer).GetBookRecommendations(ctx, req.(*GetRecommendation))
	}
	return interceptor(ctx, in, info, handler)
}

// BookAndBorrowService_ServiceDesc is the grpc.ServiceDesc for BookAndBorrowService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BookAndBorrowService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "protos.BookAndBorrowService",
	HandlerType: (*BookAndBorrowServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "IsAuthorInUseByBook",
			Handler:    _BookAndBorrowService_IsAuthorInUseByBook_Handler,
		},
		{
			MethodName: "IsCategoryInUseByBook",
			Handler:    _BookAndBorrowService_IsCategoryInUseByBook_Handler,
		},
		{
			MethodName: "CreateBook",
			Handler:    _BookAndBorrowService_CreateBook_Handler,
		},
		{
			MethodName: "GetBooks",
			Handler:    _BookAndBorrowService_GetBooks_Handler,
		},
		{
			MethodName: "GetBooksByDate",
			Handler:    _BookAndBorrowService_GetBooksByDate_Handler,
		},
		{
			MethodName: "GetBooksByName",
			Handler:    _BookAndBorrowService_GetBooksByName_Handler,
		},
		{
			MethodName: "GetBookByID",
			Handler:    _BookAndBorrowService_GetBookByID_Handler,
		},
		{
			MethodName: "EditBook",
			Handler:    _BookAndBorrowService_EditBook_Handler,
		},
		{
			MethodName: "DeleteBook",
			Handler:    _BookAndBorrowService_DeleteBook_Handler,
		},
		{
			MethodName: "DoesUserStillBorrow",
			Handler:    _BookAndBorrowService_DoesUserStillBorrow_Handler,
		},
		{
			MethodName: "CreateBorrow",
			Handler:    _BookAndBorrowService_CreateBorrow_Handler,
		},
		{
			MethodName: "CreateReturn",
			Handler:    _BookAndBorrowService_CreateReturn_Handler,
		},
		{
			MethodName: "GetBorrowings",
			Handler:    _BookAndBorrowService_GetBorrowings_Handler,
		},
		{
			MethodName: "GetBorrowingsByDate",
			Handler:    _BookAndBorrowService_GetBorrowingsByDate_Handler,
		},
		{
			MethodName: "GetBorrowingsByUserID",
			Handler:    _BookAndBorrowService_GetBorrowingsByUserID_Handler,
		},
		{
			MethodName: "GetReturns",
			Handler:    _BookAndBorrowService_GetReturns_Handler,
		},
		{
			MethodName: "GetReturnsByDate",
			Handler:    _BookAndBorrowService_GetReturnsByDate_Handler,
		},
		{
			MethodName: "GetReturnsByUserID",
			Handler:    _BookAndBorrowService_GetReturnsByUserID_Handler,
		},
		{
			MethodName: "GetOverdues",
			Handler:    _BookAndBorrowService_GetOverdues_Handler,
		},
		{
			MethodName: "EditBorrow",
			Handler:    _BookAndBorrowService_EditBorrow_Handler,
		},
		{
			MethodName: "DeleteBorrow",
			Handler:    _BookAndBorrowService_DeleteBorrow_Handler,
		},
		{
			MethodName: "GetBookRecommendations",
			Handler:    _BookAndBorrowService_GetBookRecommendations_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/protos.proto",
}
